<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outils M√©tier - Trifide 360</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <nav class="sidebar">
            <div class="logo">
                <h1>Trifide 360</h1>
                <p>Documentation Architecture</p>
            </div>
            
            <input type="text" class="search-box" placeholder="Rechercher..." id="searchBox">
            
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="index.html" class="nav-link-ok">Accueil</a>
                </li>
                <li class="nav-item">
                    <a href="vue-ensemble.html" class="nav-link-ok">Vue d'Ensemble</a>
                </li>
                <li class="nav-item has-submenu open">
                <a href="fonctionnalites-metier.html" class="nav-link-ok submenu-toggle">
                    Fonctionnalit√©s M√©tier <span class="arrow">‚ñº</span>
                </a>
                <ul class="nav-submenu">
                    <li><a href="donnees-geospatiales.html" class="nav-link-ok">Donn√©es G√©ospatiales</a></li>
                    <li><a href="visualisation-2d-3d.html" class="nav-link-ok">Visualisation 2D/3D</a></li>
                    <li><a href="creation-interactive.html" class="nav-link-ok">Cr√©ation Interactive</a></li>
                    <li><a href="outils-metier.html" class="nav-link-ok active">Outils M√©tier</a></li>
                </ul>
                </li>
                <li class="nav-item">
                    <a href="structure-code.html" class="nav-link-ok">Structure du Code</a>
                </li>
                <li class="nav-item">
                    <a href="mapping-fonctions-code.html" class="nav-link-ok">Mapping Fonctions ‚Üí Code</a>
                </li>
                <li class="nav-item">
                    <a href="flux-donnees.html" class="nav-link-ok">Flux de Donn√©es</a>
                </li>
                <li class="nav-item">
                    <a href="hierarchie-classes.html" class="nav-link">Hi√©rarchie des Classes</a>
                </li>
                <li class="nav-item">
                    <a href="communication-inter-modules.html" class="nav-link">Communication Inter-Modules</a>
                </li>
                <li class="nav-item">
                    <a href="catalogue-methodes.html" class="nav-link">Catalogue des M√©thodes</a>
                </li>
                <li class="nav-item">
                    <a href="schema-data-binding.html" class="nav-link">Data Binding & MVVM</a>
                </li>
                <li class="nav-item">
                    <a href="schema-transaction-system.html" class="nav-link">Gestion des Transactions</a>
                </li>
                <li class="nav-item">
                    <a href="cache-performance-system.html" class="nav-link">Cache et Performance</a>
                </li>
                <li class="nav-item">
                    <a href="patterns-anti-patterns-system.html" class="nav-link">Patterns & Anti-Patterns</a>
                </li>
                <li class="nav-item">
                    <a href="recommandations.html" class="nav-link">Recommandations</a>
                </li>
            </ul>
        </nav>

        <main class="main-content">
            <section class="section active">
                <h1 class="h1-ok">Outils M√©tier Sp√©cialis√©s</h1>
                
                <div class="card">
                    <h2>Vue d'Ensemble des Outils M√©tier</h2>
                    <p>Trifide 360 int√®gre une suite d'outils m√©tier sp√©cialis√©s pour les professionnels de l'arpentage, de la topographie et de la cartographie. Ces outils couvrent les calculs g√©od√©siques, les transformations de coordonn√©es, l'analyse spatiale avanc√©e, et les workflows m√©tier sp√©cifiques aux domaines de la g√©omatique professionnelle.</p>
                    
                    <div class="tech-stack">
                        <div class="tech-item-ok">
                            <h4>Calculs G√©od√©siques</h4>
                            <p>Distances, azimuts, projections</p>
                        </div>
                        <div class="tech-item-ok">
                            <h4>Transformations</h4>
                            <p>Syst√®mes coordonn√©es, datums</p>
                        </div>
                        <div class="tech-item-ok">
                            <h4>Analyse Spatiale</h4>
                            <p>Topologie, proximit√©, overlay</p>
                        </div>
                        <div class="tech-item-ok">
                            <h4>Outils Arpentage</h4>
                            <p>Polygonation, nivellement</p>
                        </div>
                        <div class="tech-item-ok">
                            <h4>Validation Qualit√©</h4>
                            <p>Contr√¥les topologiques</p>
                        </div>
                        <div class="tech-item-ok">
                            <h4>Workflows M√©tier</h4>
                            <p>Processus automatis√©s</p>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>Calculatrice G√©od√©sique</h2>

                    <div class="feature-card-ok">
                        <h4>Calculs de Distance et Azimut</h4>
                        <div class="code-block">// Calcul distance g√©od√©sique entre deux points
private void BtnCalculateDistance_Click(object sender, RoutedEventArgs e)
{
    try 
    {
        // R√©cup√©ration coordonn√©es points
        var point1 = new Point(
            double.Parse(txtLat1.Text), 
            double.Parse(txtLon1.Text)
        );
        var point2 = new Point(
            double.Parse(txtLat2.Text), 
            double.Parse(txtLon2.Text)
        );
        
        // Calcul distance orthodromique
        var distance = GeometryEngine.Distance(point1, point2);
        var azimuth = GeometryEngine.Azimuth(point1, point2);
        
        // Affichage r√©sultats
        lblDistance.Content = $"Distance: {distance:F3} m";
        lblAzimuth.Content = $"Azimut: {azimuth:F6}¬∞";
        
        // Calcul inverse optionnel
        if (chkInverse.IsChecked == true)
        {
            var backAzimuth = (azimuth + 180) % 360;
            lblBackAzimuth.Content = $"Azimut inverse: {backAzimuth:F6}¬∞";
        }
    }
    catch (Exception ex)
    {
        ShowError($"Erreur calcul: {ex.Message}");
    }
}</div>
                        
                        <ul>
                            <li><strong>Distance orthodromique</strong> - Calcul distance la plus courte sur ellipso√Øde</li>
                            <li><strong>Azimut direct/inverse</strong> - Direction g√©od√©sique entre points</li>
                            <li><strong>Probl√®me direct</strong> - Point destination depuis point origine + distance + azimut</li>
                            <li><strong>Probl√®me inverse</strong> - Distance et azimut entre deux points connus</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h2>Transformations de Coordonn√©es</h2>
                    
                    <div class="features-grid">
                        <div class="feature-card-ok">
                            <h4>Transformations de Datum</h4>
                            <div class="code-block">// Transformation NAD83 ‚Üí WGS84
private Point TransformDatum(Point inputPoint, string sourceDatum, string targetDatum)
{
    var sourceRef = SpatialReference.Create(sourceDatum);
    var targetRef = SpatialReference.Create(targetDatum);
    
    // Application transformation 7 param√®tres
    var transformation = GeometryEngine.Project(
        inputPoint, sourceRef, targetRef
    );
    
    return transformation as Point;
}</div>
                            <ul>
                                <li>NAD83(CSRS) ‚Üî WGS84</li>
                                <li>NAD27 ‚Üí NAD83</li>
                                <li>Transformations locales</li>
                                <li>Param√®tres Helmert 7</li>
                            </ul>
                        </div>

                        <div class="feature-card-ok">
                            <h4>Projections Cartographiques</h4>
                            <div class="code-block">// Conversion g√©ographique ‚Üí UTM
private Point ConvertToUTM(Point geoPoint)
{
    // D√©termination zone UTM automatique
    int zone = (int)Math.Floor((geoPoint.X + 180) / 6) + 1;
    bool isNorth = geoPoint.Y >= 0;
    
    // Cr√©ation r√©f√©rence UTM
    var utmRef = SpatialReference.Create(
        $"EPSG:{(isNorth ? 32600 : 32700) + zone}"
    );
    
    return GeometryEngine.Project(geoPoint, 
        SpatialReferences.Wgs84, utmRef) as Point;
}</div>
                            <ul>
                                <li>UTM (zones 17-22 Canada)</li>
                                <li>MTM (Modified Transverse Mercator)</li>
                                <li>Lambert Conformal Conic</li>
                                <li>St√©r√©ographique polaire</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>Outils d'Analyse Spatiale</h2>
                    
                    <div class="features-grid">
                        <div class="feature-card-ok">
                            <h4>Analyse de Proximit√©</h4>
                            <div class="code-block">// Zone tampon et analyse proximit√©
private void AnalyzeProximity()
{
    var selectedFeatures = GetSelectedFeatures();
    var bufferDistance = double.Parse(txtBufferDistance.Text);
    
    foreach (var feature in selectedFeatures)
    {
        // Cr√©ation zone tampon
        var buffer = GeometryEngine.Buffer(
            feature.Geometry, bufferDistance
        );
        
        // Recherche features dans tampon
        var nearbyFeatures = spatialIndex.Query(buffer.Extent)
            .Where(f => GeometryEngine.Intersects(f.Geometry, buffer))
            .ToList();
            
        // Analyse densit√©
        var density = nearbyFeatures.Count / buffer.Area;
        
        // Mise √† jour attributs
        feature.SetAttribute("NEARBY_COUNT", nearbyFeatures.Count);
        feature.SetAttribute("DENSITY", density);
    }
}</div>
                            <ul>
                                <li><strong>Zones tampons</strong> - Distances fixes/variables</li>
                                <li><strong>Plus proches voisins</strong> - K-NN spatial</li>
                                <li><strong>Analyse densit√©</strong> - Points par unit√© surface</li>
                                <li><strong>Clusters spatiaux</strong> - D√©tection agr√©gation</li>
                            </ul>
                        </div>

                        <div class="feature-card-ok">
                            <h4>Op√©rations Topologiques</h4>
                            <div class="code-block">// Intersection et analyse overlay
private void PerformOverlayAnalysis()
{
    var layer1 = GetLayerByName("Parcelles");
    var layer2 = GetLayerByName("Zones_Inondables");
    
    var results = new List&lt;Feature&gt;();
    
    foreach (var parcel in layer1.Features)
    {
        foreach (var floodZone in layer2.Features)
        {
            // Test intersection
            if (GeometryEngine.Intersects(parcel.Geometry, floodZone.Geometry))
            {
                // Calcul intersection pr√©cise
                var intersection = GeometryEngine.Intersection(
                    parcel.Geometry, floodZone.Geometry
                );
                
                if (intersection != null && !intersection.IsEmpty)
                {
                    // Cr√©ation feature r√©sultat
                    var result = new Feature(intersection);
                    result.CopyAttributesFrom(parcel, "PARCEL_");
                    result.CopyAttributesFrom(floodZone, "FLOOD_");
                    
                    // Calcul pourcentage intersection
                    var percentage = (intersection.Area / parcel.Geometry.Area) * 100;
                    result.SetAttribute("FLOOD_PERCENTAGE", percentage);
                    
                    results.Add(result);
                }
            }
        }
    }
    
    // Cr√©ation couche r√©sultat
    CreateResultLayer("Parcelles_Inondables", results);
}</div>
                            <ul>
                                <li><strong>Intersection</strong> - Zones communes</li>
                                <li><strong>Union</strong> - Fusion g√©om√©tries</li>
                                <li><strong>Diff√©rence</strong> - Soustraction zones</li>
                                <li><strong>D√©coupage</strong> - Clip par masque</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>Outils Arpentage Sp√©cialis√©s</h2>
                    
                    <div class="features-grid">
                        <div class="feature-card-ok">
                            <h4>Calculs de Polygonation</h4>
                            <div class="code-block">// Calcul polygonale ferm√©e
private PolygonationResult CalculateClosedTraverse()
{
    var traverse = GetTraversePoints();
    var result = new PolygonationResult();
    
    double totalAngleSum = 0;
    double totalDistance = 0;
    double linearMisclosure = 0;
    
    // Calcul somme angles
    for (int i = 0; i &lt; traverse.Count; i++)
    {
        var angle = CalculateInternalAngle(
            traverse[i-1], traverse[i], traverse[i+1]
        );
        totalAngleSum += angle;
    }
    
    // Erreur angulaire
    var theoreticalSum = (traverse.Count - 2) * 180;
    var angularError = totalAngleSum - theoreticalSum;
    
    // Distribution correction angulaire
    var angularCorrection = angularError / traverse.Count;
    
    // Calcul coordonn√©es corrig√©es
    var correctedPoints = DistributeAngularError(traverse, angularCorrection);
    
    // Fermeture lin√©aire
    linearMisclosure = CalculateLinearMisclosure(correctedPoints);
    
    result.AngularError = angularError;
    result.LinearMisclosure = linearMisclosure;
    result.Precision = totalDistance / linearMisclosure;
    result.CorrectedPoints = correctedPoints;
    
    return result;
}</div>
                            <ul>
                                <li><strong>Polygonale ferm√©e</strong> - Contr√¥le fermeture angulaire/lin√©aire</li>
                                <li><strong>Polygonale ouverte</strong> - Rattachement points connus</li>
                                <li><strong>Compensation</strong> - Distribution erreurs</li>
                                <li><strong>Pr√©cision</strong> - Calcul indicateurs qualit√©</li>
                            </ul>
                        </div>

                        <div class="feature-card-ok">
                            <h4>Nivellement et Altim√©trie</h4>
                            <div class="code-block">// Calcul cheminement altim√©trique
private LevelingResult CalculateLeveling()
{
    var levelingPoints = GetLevelingSequence();
    var result = new LevelingResult();
    
    double cumulativeDistance = 0;
    double heightDifference = 0;
    
    for (int i = 0; i &lt; levelingPoints.Count - 1; i++)
    {
        var point1 = levelingPoints[i];
        var point2 = levelingPoints[i + 1];
        
        // Distance horizontale
        var distance = GeometryEngine.Distance(point1, point2);
        cumulativeDistance += distance;
        
        // D√©nivel√©e observ√©e
        var deltaH = point2.Z - point1.Z;
        heightDifference += deltaH;
        
        // Correction courbure/r√©fraction
        var correction = CalculateCurvatureCorrection(distance);
        var correctedDeltaH = deltaH + correction;
        
        point2.CorrectedElevation = point1.CorrectedElevation + correctedDeltaH;
    }
    
    // Erreur fermeture (si circuit ferm√©)
    if (IsClosedCircuit(levelingPoints))
    {
        result.ClosureError = heightDifference;
        result.TolerableError = CalculateTolerableError(cumulativeDistance);
        result.IsAcceptable = Math.Abs(result.ClosureError) &lt;= result.TolerableError;
    }
    
    return result;
}</div>
                            <ul>
                                <li><strong>Nivellement g√©om√©trique</strong> - Haute pr√©cision</li>
                                <li><strong>Nivellement trigonom√©trique</strong> - Longues distances</li>
                                <li><strong>Correction courbure</strong> - R√©fraction atmosph√©rique</li>
                                <li><strong>Compensation altim√©trique</strong> - Distribution erreurs</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>Validation et Contr√¥le Qualit√©</h2>

                    <div class="feature-card-ok">
                        <h4>Contr√¥les Topologiques Automatis√©s</h4>
                        <div class="code-block">// Validation topologique compl√®te
private TopologyValidationReport ValidateTopology(FeatureLayer layer)
{
    var report = new TopologyValidationReport();
    var features = layer.GetAllFeatures();
    
    // Contr√¥le 1: G√©om√©tries valides
    foreach (var feature in features)
    {
        if (!GeometryEngine.IsValid(feature.Geometry))
        {
            var error = new TopologyError
            {
                Type = TopologyErrorType.InvalidGeometry,
                Feature = feature,
                Description = "G√©om√©trie invalide (auto-intersection, etc.)",
                Severity = ErrorSeverity.High
            };
            report.Errors.Add(error);
        }
    }
    
    // Contr√¥le 2: Doublons g√©om√©triques
    for (int i = 0; i &lt; features.Count; i++)
    {
        for (int j = i + 1; j &lt; features.Count; j++)
        {
            if (GeometryEngine.Equals(features[i].Geometry, features[j].Geometry))
            {
                report.Errors.Add(new TopologyError
                {
                    Type = TopologyErrorType.DuplicateGeometry,
                    Features = new[] { features[i], features[j] },
                    Description = $"G√©om√©tries identiques: {features[i].ObjectID} et {features[j].ObjectID}",
                    Severity = ErrorSeverity.Medium
                });
            }
        }
    }
    
    // Contr√¥le 3: Chevauchements (polygones)
    if (layer.GeometryType == GeometryType.Polygon)
    {
        var overlaps = FindPolygonOverlaps(features);
        foreach (var overlap in overlaps)
        {
            report.Errors.Add(new TopologyError
            {
                Type = TopologyErrorType.Overlap,
                Features = overlap.Features,
                Geometry = overlap.OverlapGeometry,
                Description = $"Chevauchement d√©tect√© (surface: {overlap.OverlapGeometry.Area:F2} m¬≤)",
                Severity = ErrorSeverity.Medium
            });
        }
    }
    
    // Contr√¥le 4: √âcarts (gaps) entre polygones adjacents
    var gaps = FindGapsBetweenPolygons(features);
    foreach (var gap in gaps)
    {
        if (gap.Area > minGapThreshold)
        {
            report.Errors.Add(new TopologyError
            {
                Type = TopologyErrorType.Gap,
                Geometry = gap,
                Description = $"√âcart d√©tect√© (surface: {gap.Area:F2} m¬≤)",
                Severity = ErrorSeverity.Low
            });
        }
    }
    
    return report;
}</div>
                        
                        <ul>
                            <li><strong>G√©om√©tries invalides</strong> - Auto-intersections, n≈ìuds pendants</li>
                            <li><strong>Doublons</strong> - D√©tection g√©om√©tries identiques</li>
                            <li><strong>Chevauchements</strong> - Zones communes non autoris√©es</li>
                            <li><strong>√âcarts (gaps)</strong> - Espaces entre polygones adjacents</li>
                            <li><strong>Connectivit√©</strong> - V√©rification continuit√© r√©seaux</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h2>Workflows M√©tier Automatis√©s</h2>
                    
                    <div class="features-grid">
                        <div class="feature-card-ok">
                            <h4>Workflow Import et Validation</h4>
                            <div class="code-block">// Processus automatis√© import/validation
private async Task&lt;ImportWorkflowResult&gt; ExecuteImportWorkflow(string filePath)
{
    var workflow = new ImportWorkflow();
    var result = new ImportWorkflowResult();
    
    try
    {
        // √âtape 1: Validation format fichier
        workflow.AddStep("Validation Format", () =&gt; 
        {
            return ValidateFileFormat(filePath);
        });
        
        // √âtape 2: Import donn√©es
        workflow.AddStep("Import Donn√©es", () =&gt; 
        {
            return ImportGeospatialData(filePath);
        });
        
        // √âtape 3: Validation g√©om√©trique
        workflow.AddStep("Validation G√©om√©trique", (data) =&gt; 
        {
            return ValidateGeometries(data as FeatureCollection);
        });
        
        // √âtape 4: Validation attributaire
        workflow.AddStep("Validation Attributaire", (data) =&gt; 
        {
            return ValidateAttributes(data as FeatureCollection);
        });
        
        // √âtape 5: Correction automatique
        workflow.AddStep("Correction Automatique", (data) =&gt; 
        {
            return AutoCorrectIssues(data as FeatureCollection);
        });
        
        // √âtape 6: G√©n√©ration rapport
        workflow.AddStep("G√©n√©ration Rapport", (data) =&gt; 
        {
            return GenerateQualityReport(data as FeatureCollection);
        });
        
        // Ex√©cution workflow
        result = await workflow.ExecuteAsync();
        
    }
    catch (Exception ex)
    {
        result.Success = false;
        result.ErrorMessage = ex.Message;
    }
    
    return result;
}</div>
                        </div>

                        <div class="feature-card-ok">
                            <h4>Workflow Analyse et Export</h4>
                            <div class="code-block">// Processus analyse spatiale automatis√©e
private async Task&lt;AnalysisWorkflowResult&gt; ExecuteSpatialAnalysisWorkflow()
{
    var workflow = new SpatialAnalysisWorkflow();
    
    // Configuration param√®tres
    workflow.SetParameter("BufferDistance", 100.0);
    workflow.SetParameter("DensityThreshold", 0.005);
    workflow.SetParameter("ExportFormat", "Shapefile");
    
    // √âtapes analyse
    workflow.AddStep("S√©lection Donn√©es", () =&gt; SelectDataLayers());
    workflow.AddStep("Cr√©ation Tampons", (data) =&gt; CreateBufferZones(data));
    workflow.AddStep("Analyse Intersection", (buffers) =&gt; PerformIntersectionAnalysis(buffers));
    workflow.AddStep("Calcul Statistiques", (results) =&gt; CalculateStatistics(results));
    workflow.AddStep("G√©n√©ration Cartes", (stats) =&gt; GenerateMaps(stats));
    workflow.AddStep("Export R√©sultats", (maps) =&gt; ExportResults(maps));
    
    return await workflow.ExecuteAsync();
}</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>üîó Navigation</h2>
                    <div class="features-grid">

                        <div class="feature-card-ok">
                            <h4><a href="donnees-geospatiales.html" class="nav-link-ok" style="margin-top: 10px; display: inline-block;">‚¨ÖÔ∏è Donn√©es G√©ospatiales</a></h4>
                            <p>Formats et projections support√©s</p>
                        </div>
                        <div class="feature-card-ok">
                            <h4><a href="visualisation-2d-3d.html" class="nav-link-ok" style="margin-top: 10px; display: inline-block;">‚¨ÖÔ∏è Visualisation 2D/3D</a></h4>
                            <p>Rendu cartographique et 3D</p>
                        </div>
                        <div class="feature-card-ok">
                            <h4><a href="creation-interactive.html" class="nav-link-ok" style="margin-top: 10px; display: inline-block;">‚¨ÖÔ∏è Cr√©ation Interactive</a></h4>
                            <p>Outils d'√©dition avanc√©s</p>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>
</body>
</html>