<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classes GÃ©omÃ©triques - Trifide 360</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <nav class="sidebar">
            <div class="logo">
                <h1>Trifide 360</h1>
                <p>Documentation Architecture</p>
            </div>
            
            <input type="text" class="search-box" placeholder="Rechercher..." id="searchBox">
            
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">ğŸ  Accueil</a>
                </li>
                <li class="nav-item">
                    <a href="vue-ensemble.html" class="nav-link">Vue d'Ensemble</a>
                </li>
                <li class="nav-item">
                    <a href="fonctionnalites-metier.html" class="nav-link">FonctionnalitÃ©s MÃ©tier</a>
                    <ul class="nav-submenu">
                        <li><a href="donnees-geospatiales.html" class="nav-link">DonnÃ©es GÃ©ospatiales</a></li>
                        <li><a href="visualisation-2d-3d.html" class="nav-link">Visualisation 2D/3D</a></li>
                        <li><a href="creation-interactive.html" class="nav-link">CrÃ©ation Interactive</a></li>
                    </ul>
                </li>
                <li class="nav-item">
                    <a href="structure-code.html" class="nav-link">Structure du Code</a>
                </li>
                <li class="nav-item">
                    <a href="mapping-fonctions-code.html" class="nav-link">Mapping Fonctions â†” Code</a>
                </li>
                <li class="nav-item">
                    <a href="flux-donnees.html" class="nav-link">Flux de DonnÃ©es</a>
                </li>
                <li class="nav-item">
                    <a href="hierarchie-classes.html" class="nav-link">HiÃ©rarchie des Classes</a>
                </li>
                <li class="nav-item">
                    <a href="communication-inter-modules.html" class="nav-link">Communication Inter-Modules</a>
                </li>
                <li class="nav-item">
                    <a href="catalogue-methodes.html" class="nav-link">Catalogue des MÃ©thodes</a>
                </li>
                <li class="nav-item">
                    <a href="patterns-anti-patterns.html" class="nav-link">Patterns & Anti-Patterns</a>
                </li>
                <li class="nav-item">
                    <a href="recommandations.html" class="nav-link">Recommandations</a>
                </li>
            </ul>
        </nav>

        <main class="main-content">
            <section class="section active">
                <h1>ğŸ“ Classes GÃ©omÃ©triques (GISMind.Geometry)</h1>
                
                <div class="card">
                    <h2>Vue d'Ensemble du Namespace</h2>
                    <p>Le namespace <strong>GISMind.Geometry</strong> constitue le cÅ“ur gÃ©omÃ©trique de Trifide 360. Il fournit une hiÃ©rarchie de classes robuste pour la manipulation de gÃ©omÃ©tries spatiales 2D/3D avec support complet des opÃ©rations gÃ©odÃ©siques.</p>
                    
                    <div class="tech-stack">
                        <div class="tech-item">
                            <h4>ğŸ”º Geometry</h4>
                            <p>Classe abstraite de base</p>
                        </div>
                        <div class="tech-item">
                            <h4>ğŸ“ Point</h4>
                            <p>GÃ©omÃ©trie ponctuelle 3D+M</p>
                        </div>
                        <div class="tech-item">
                            <h4>ğŸ“ Polyline</h4>
                            <p>GÃ©omÃ©trie linÃ©aire</p>
                        </div>
                        <div class="tech-item">
                            <h4>ğŸ”· Polygon</h4>
                            <p>GÃ©omÃ©trie surfacique</p>
                        </div>
                        <div class="tech-item">
                            <h4>ğŸ¯ Collections</h4>
                            <p>Multi-gÃ©omÃ©tries</p>
                        </div>
                        <div class="tech-item">
                            <h4>âš¡ Engine</h4>
                            <p>Moteur de calculs</p>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>HiÃ©rarchie ComplÃ¨te des Classes GÃ©omÃ©triques</h2>
                    
                    <div class="file-structure">ğŸ”º <strong>Geometry</strong> (abstract class) <em>- Classe de base abstraite</em>
â”œâ”€â”€ <strong>Properties communes :</strong>
â”‚   â”œâ”€â”€ SpatialReference SpatialRef { get; set; }
â”‚   â”œâ”€â”€ Envelope Extent { get; }
â”‚   â”œâ”€â”€ GeometryType Type { get; }
â”‚   â”œâ”€â”€ bool IsEmpty { get; }
â”‚   â””â”€â”€ bool IsValid { get; }
â”œâ”€â”€ <strong>Methods abstraites :</strong>
â”‚   â”œâ”€â”€ Geometry Clone()
â”‚   â”œâ”€â”€ bool Equals(Geometry other)
â”‚   â”œâ”€â”€ string ToWKT()
â”‚   â””â”€â”€ byte[] ToBinary()
â””â”€â”€ <strong>Operators :</strong>
    â”œâ”€â”€ bool operator ==(Geometry a, Geometry b)
    â””â”€â”€ bool operator !=(Geometry a, Geometry b)

â”œâ”€ ğŸ“ <strong>Point : Geometry</strong>
â”‚  â”œâ”€â”€ <strong>Properties :</strong>
â”‚  â”‚   â”œâ”€â”€ double X { get; set; }
â”‚  â”‚   â”œâ”€â”€ double Y { get; set; }
â”‚  â”‚   â”œâ”€â”€ double Z { get; set; }  <em># CoordonnÃ©e altimÃ©trique</em>
â”‚  â”‚   â”œâ”€â”€ double M { get; set; }  <em># Mesure linÃ©aire</em>
â”‚  â”‚   â”œâ”€â”€ bool HasZ { get; }
â”‚  â”‚   â””â”€â”€ bool HasM { get; }
â”‚  â”œâ”€â”€ <strong>Constructors :</strong>
â”‚  â”‚   â”œâ”€â”€ Point()  <em># Point vide</em>
â”‚  â”‚   â”œâ”€â”€ Point(double x, double y)
â”‚  â”‚   â”œâ”€â”€ Point(double x, double y, double z)
â”‚  â”‚   â””â”€â”€ Point(double x, double y, double z, double m)
â”‚  â”œâ”€â”€ <strong>Methods :</strong>
â”‚  â”‚   â”œâ”€â”€ double Distance(Point other)
â”‚  â”‚   â”œâ”€â”€ Point MidPoint(Point other)
â”‚  â”‚   â”œâ”€â”€ double Bearing(Point other)
â”‚  â”‚   â”œâ”€â”€ Point Project(double distance, double bearing)
â”‚  â”‚   â””â”€â”€ Point Transform(SpatialReference target)
â”‚  â”œâ”€â”€ <strong>Operators surchargÃ©s :</strong>
â”‚  â”‚   â”œâ”€â”€ Point operator +(Point a, Point b)
â”‚  â”‚   â”œâ”€â”€ Point operator -(Point a, Point b)
â”‚  â”‚   â”œâ”€â”€ Point operator *(Point p, double scalar)
â”‚  â”‚   â”œâ”€â”€ Point operator /(Point p, double scalar)
â”‚  â”‚   â””â”€â”€ double operator |(Point a, Point b)  <em># Produit scalaire</em>
â”‚  â””â”€â”€ <strong>Static Members :</strong>
â”‚      â”œâ”€â”€ Point Origin { get; }  <em># (0, 0, 0)</em>
â”‚      â”œâ”€â”€ Point Empty { get; }
â”‚      â””â”€â”€ Point Parse(string wkt)

â”œâ”€ ğŸ“ <strong>Polyline : Geometry, IEnumerable&lt;Point&gt;</strong>
â”‚  â”œâ”€â”€ <strong>Properties :</strong>
â”‚  â”‚   â”œâ”€â”€ List&lt;Point&gt; Points { get; }
â”‚  â”‚   â”œâ”€â”€ int PointCount { get; }
â”‚  â”‚   â”œâ”€â”€ int PartCount { get; }
â”‚  â”‚   â”œâ”€â”€ bool IsClosed { get; }
â”‚  â”‚   â”œâ”€â”€ double Length { get; }
â”‚  â”‚   â”œâ”€â”€ Point StartPoint { get; }
â”‚  â”‚   â””â”€â”€ Point EndPoint { get; }
â”‚  â”œâ”€â”€ <strong>Constructors :</strong>
â”‚  â”‚   â”œâ”€â”€ Polyline()
â”‚  â”‚   â”œâ”€â”€ Polyline(IEnumerable&lt;Point&gt; points)
â”‚  â”‚   â””â”€â”€ Polyline(Point[] points)
â”‚  â”œâ”€â”€ <strong>Methods :</strong>
â”‚  â”‚   â”œâ”€â”€ void AddPoint(Point point)
â”‚  â”‚   â”œâ”€â”€ void InsertPoint(int index, Point point)
â”‚  â”‚   â”œâ”€â”€ void RemovePoint(int index)
â”‚  â”‚   â”œâ”€â”€ Point GetPoint(int index)
â”‚  â”‚   â”œâ”€â”€ void SetPoint(int index, Point point)
â”‚  â”‚   â”œâ”€â”€ Polyline Reverse()
â”‚  â”‚   â”œâ”€â”€ Polyline Simplify(double tolerance)
â”‚  â”‚   â”œâ”€â”€ Polyline Smooth(int iterations)
â”‚  â”‚   â”œâ”€â”€ Point[] GetPoints()
â”‚  â”‚   â”œâ”€â”€ double LengthBetween(int startIndex, int endIndex)
â”‚  â”‚   â””â”€â”€ Point InterpolatePoint(double distance)
â”‚  â”œâ”€â”€ <strong>Indexer :</strong>
â”‚  â”‚   â””â”€â”€ Point this[int index] { get; set; }
â”‚  â””â”€â”€ <strong>IEnumerable :</strong>
â”‚      â”œâ”€â”€ IEnumerator&lt;Point&gt; GetEnumerator()
â”‚      â””â”€â”€ IEnumerator IEnumerable.GetEnumerator()

â”œâ”€ ğŸ”· <strong>Polygon : Geometry</strong>
â”‚  â”œâ”€â”€ <strong>Properties :</strong>
â”‚  â”‚   â”œâ”€â”€ List&lt;Polyline&gt; Rings { get; }
â”‚  â”‚   â”œâ”€â”€ Polyline ExteriorRing { get; }
â”‚  â”‚   â”œâ”€â”€ List&lt;Polyline&gt; InteriorRings { get; }
â”‚  â”‚   â”œâ”€â”€ int RingCount { get; }
â”‚  â”‚   â”œâ”€â”€ double Area { get; }
â”‚  â”‚   â”œâ”€â”€ double Perimeter { get; }
â”‚  â”‚   â””â”€â”€ Point Centroid { get; }
â”‚  â”œâ”€â”€ <strong>Constructors :</strong>
â”‚  â”‚   â”œâ”€â”€ Polygon()
â”‚  â”‚   â”œâ”€â”€ Polygon(Polyline exteriorRing)
â”‚  â”‚   â””â”€â”€ Polygon(Polyline exterior, IEnumerable&lt;Polyline&gt; holes)
â”‚  â”œâ”€â”€ <strong>Methods :</strong>
â”‚  â”‚   â”œâ”€â”€ void SetExteriorRing(Polyline ring)
â”‚  â”‚   â”œâ”€â”€ void AddInteriorRing(Polyline ring)
â”‚  â”‚   â”œâ”€â”€ void RemoveInteriorRing(int index)
â”‚  â”‚   â”œâ”€â”€ bool ContainsPoint(Point point)
â”‚  â”‚   â”œâ”€â”€ bool IsGeometryValid()
â”‚  â”‚   â”œâ”€â”€ bool Intersects(Geometry other)
â”‚  â”‚   â”œâ”€â”€ Geometry Union(Polygon other)
â”‚  â”‚   â”œâ”€â”€ Geometry Intersection(Polygon other)
â”‚  â”‚   â”œâ”€â”€ Geometry Difference(Polygon other)
â”‚  â”‚   â”œâ”€â”€ Polygon Buffer(double distance)
â”‚  â”‚   â”œâ”€â”€ Point LabelPoint()
â”‚  â”‚   â”œâ”€â”€ Polygon ConvexHull()
â”‚  â”‚   â””â”€â”€ Polygon[] Split(Polyline splitter)
â”‚  â””â”€â”€ <strong>Validation :</strong>
â”‚      â”œâ”€â”€ bool HasSelfIntersections()
â”‚      â”œâ”€â”€ bool RingsAreValid()
â”‚      â””â”€â”€ ValidationResult ValidateTopology()

â”œâ”€ ğŸ¯ <strong>MultiPoint : Geometry, ICollection&lt;Point&gt;</strong>
â”‚  â”œâ”€â”€ <strong>Properties :</strong>
â”‚  â”‚   â”œâ”€â”€ List&lt;Point&gt; Points { get; }
â”‚  â”‚   â”œâ”€â”€ int Count { get; }
â”‚  â”‚   â””â”€â”€ Envelope ConvexHull { get; }
â”‚  â”œâ”€â”€ <strong>Methods :</strong>
â”‚  â”‚   â”œâ”€â”€ void Add(Point point)
â”‚  â”‚   â”œâ”€â”€ bool Remove(Point point)
â”‚  â”‚   â”œâ”€â”€ bool Contains(Point point)
â”‚  â”‚   â”œâ”€â”€ void Clear()
â”‚  â”‚   â”œâ”€â”€ Point[] ToArray()
â”‚  â”‚   â””â”€â”€ Envelope BoundingBox()
â”‚  â””â”€â”€ <strong>Indexer :</strong>
â”‚      â””â”€â”€ Point this[int index] { get; set; }

â”œâ”€ ğŸ”— <strong>MultiLineString : Geometry, ICollection&lt;Polyline&gt;</strong>
â”‚  â”œâ”€â”€ <strong>Properties :</strong>
â”‚  â”‚   â”œâ”€â”€ List&lt;Polyline&gt; Lines { get; }
â”‚  â”‚   â”œâ”€â”€ int Count { get; }
â”‚  â”‚   â””â”€â”€ double TotalLength { get; }
â”‚  â”œâ”€â”€ <strong>Methods :</strong>
â”‚  â”‚   â”œâ”€â”€ void Add(Polyline line)
â”‚  â”‚   â”œâ”€â”€ bool Remove(Polyline line)
â”‚  â”‚   â”œâ”€â”€ bool Contains(Polyline line)
â”‚  â”‚   â”œâ”€â”€ void Clear()
â”‚  â”‚   â”œâ”€â”€ Polyline Merge()
â”‚  â”‚   â””â”€â”€ MultiLineString Split(Point splitPoint)
â”‚  â””â”€â”€ <strong>Indexer :</strong>
â”‚      â””â”€â”€ Polyline this[int index] { get; set; }

â”œâ”€ ğŸ¢ <strong>MultiPolygon : Geometry, ICollection&lt;Polygon&gt;</strong>
â”‚  â”œâ”€â”€ <strong>Properties :</strong>
â”‚  â”‚   â”œâ”€â”€ List&lt;Polygon&gt; Polygons { get; }
â”‚  â”‚   â”œâ”€â”€ int Count { get; }
â”‚  â”‚   â””â”€â”€ double TotalArea { get; }
â”‚  â”œâ”€â”€ <strong>Methods :</strong>
â”‚  â”‚   â”œâ”€â”€ void Add(Polygon polygon)
â”‚  â”‚   â”œâ”€â”€ bool Remove(Polygon polygon)
â”‚  â”‚   â”œâ”€â”€ bool Contains(Polygon polygon)
â”‚  â”‚   â”œâ”€â”€ void Clear()
â”‚  â”‚   â”œâ”€â”€ Polygon Union()
â”‚  â”‚   â””â”€â”€ MultiPolygon Dissolve()
â”‚  â””â”€â”€ <strong>Indexer :</strong>
â”‚      â””â”€â”€ Polygon this[int index] { get; set; }

â””â”€ ğŸ² <strong>MultiPatch : Geometry</strong> <em>(GÃ©omÃ©tries 3D Complexes)</em>
   â”œâ”€â”€ <strong>Properties :</strong>
   â”‚   â”œâ”€â”€ List&lt;Triangle&gt; Triangles { get; }
   â”‚   â”œâ”€â”€ List&lt;Surface&gt; Surfaces { get; }
   â”‚   â”œâ”€â”€ SurfaceType Type { get; set; }
   â”‚   â”œâ”€â”€ bool HasTextures { get; }
   â”‚   â”œâ”€â”€ double Volume { get; }
   â”‚   â””â”€â”€ double SurfaceArea { get; }
   â”œâ”€â”€ <strong>Methods :</strong>
   â”‚   â”œâ”€â”€ void AddTriangle(Triangle triangle)
   â”‚   â”œâ”€â”€ void AddSurface(Surface surface)
   â”‚   â”œâ”€â”€ double CalculateVolume()
   â”‚   â”œâ”€â”€ double CalculateSurfaceArea()
   â”‚   â”œâ”€â”€ void ApplyTexture(Texture texture)
   â”‚   â”œâ”€â”€ Mesh ExportToMesh()
   â”‚   â””â”€â”€ bool IsWatertight()
   â””â”€â”€ <strong>Enums :</strong>
       â”œâ”€â”€ SurfaceType { TriangleStrip, TriangleFan, Triangles, Ring }
       â””â”€â”€ TextureType { Diffuse, Normal, Specular, Ambient }</div>
                </div>

                <div class="card">
                    <h2>Classes Support et Utilitaires</h2>
                    
                    <div class="file-structure">ğŸ“¦ <strong>Envelope : IEquatable&lt;Envelope&gt;</strong> <em>- BoÃ®te englobante</em>
â”œâ”€â”€ <strong>Properties :</strong>
â”‚   â”œâ”€â”€ double XMin, XMax { get; set; }
â”‚   â”œâ”€â”€ double YMin, YMax { get; set; }
â”‚   â”œâ”€â”€ double ZMin, ZMax { get; set; }  <em># Support 3D</em>
â”‚   â”œâ”€â”€ Point Center { get; }
â”‚   â”œâ”€â”€ double Width { get; }
â”‚   â”œâ”€â”€ double Height { get; }
â”‚   â””â”€â”€ bool IsEmpty { get; }
â”œâ”€â”€ <strong>Constructors :</strong>
â”‚   â”œâ”€â”€ Envelope()
â”‚   â”œâ”€â”€ Envelope(double xMin, double yMin, double xMax, double yMax)
â”‚   â””â”€â”€ Envelope(Point min, Point max)
â”œâ”€â”€ <strong>Methods :</strong>
â”‚   â”œâ”€â”€ bool Contains(Point point)
â”‚   â”œâ”€â”€ bool Contains(Envelope other)
â”‚   â”œâ”€â”€ bool Intersects(Envelope other)
â”‚   â”œâ”€â”€ Envelope Union(Envelope other)
â”‚   â”œâ”€â”€ Envelope Intersection(Envelope other)
â”‚   â”œâ”€â”€ void Expand(double distance)
â”‚   â”œâ”€â”€ void ExpandToInclude(Point point)
â”‚   â””â”€â”€ Point[] GetCorners()
â””â”€â”€ <strong>Static :</strong>
    â”œâ”€â”€ Envelope Empty { get; }
    â””â”€â”€ Envelope CreateFrom(IEnumerable&lt;Point&gt; points)

âš¡ <strong>GeometryEngine : static class</strong> <em>- Moteur de calculs gÃ©omÃ©triques</em>
â”œâ”€â”€ <strong>Mesures et Calculs :</strong>
â”‚   â”œâ”€â”€ double Distance(Geometry geom1, Geometry geom2, SpatialReference sref)
â”‚   â”œâ”€â”€ double Area(Geometry geometry, AreaUnit unit)
â”‚   â”œâ”€â”€ double Length(Geometry geometry, LinearUnit unit)
â”‚   â”œâ”€â”€ double Volume(Geometry geometry, VolumeUnit unit)
â”‚   â””â”€â”€ Point Centroid(Geometry geometry)
â”œâ”€â”€ <strong>OpÃ©rations Topologiques :</strong>
â”‚   â”œâ”€â”€ bool Intersects(Geometry geom1, Geometry geom2)
â”‚   â”œâ”€â”€ bool Contains(Geometry container, Geometry contained)
â”‚   â”œâ”€â”€ bool Within(Geometry inner, Geometry outer)
â”‚   â”œâ”€â”€ bool Overlaps(Geometry geom1, Geometry geom2)
â”‚   â”œâ”€â”€ bool Touches(Geometry geom1, Geometry geom2)
â”‚   â”œâ”€â”€ bool Crosses(Geometry geom1, Geometry geom2)
â”‚   â””â”€â”€ bool Disjoint(Geometry geom1, Geometry geom2)
â”œâ”€â”€ <strong>OpÃ©rations de Construction :</strong>
â”‚   â”œâ”€â”€ Geometry Union(Geometry[] geometries)
â”‚   â”œâ”€â”€ Geometry Intersection(Geometry geom1, Geometry geom2)
â”‚   â”œâ”€â”€ Geometry Difference(Geometry minuend, Geometry subtrahend)
â”‚   â”œâ”€â”€ Geometry SymmetricDifference(Geometry geom1, Geometry geom2)
â”‚   â”œâ”€â”€ Geometry Buffer(Geometry geometry, double distance, SpatialReference sref)
â”‚   â”œâ”€â”€ Geometry ConvexHull(Geometry geometry)
â”‚   â””â”€â”€ Point LabelPoint(Polygon polygon)
â”œâ”€â”€ <strong>Transformation et Projection :</strong>
â”‚   â”œâ”€â”€ Geometry Project(Geometry geometry, SpatialReference source, SpatialReference target)
â”‚   â”œâ”€â”€ Geometry Simplify(Geometry geometry, double tolerance)
â”‚   â”œâ”€â”€ Geometry Generalize(Geometry geometry, double maxDeviation)
â”‚   â””â”€â”€ Geometry DensifyByLength(Geometry geometry, double maxLength)
â”œâ”€â”€ <strong>Validation :</strong>
â”‚   â”œâ”€â”€ bool IsValid(Geometry geometry)
â”‚   â”œâ”€â”€ ValidationResult ValidateGeometry(Geometry geometry)
â”‚   â”œâ”€â”€ Geometry CorrectGeometry(Geometry geometry)
â”‚   â””â”€â”€ string[] GetValidationErrors(Geometry geometry)
â””â”€â”€ <strong>Utilitaires :</strong>
    â”œâ”€â”€ Envelope GetExtent(Geometry[] geometries)
    â”œâ”€â”€ GeometryType GetGeometryType(Geometry geometry)
    â”œâ”€â”€ int GetPointCount(Geometry geometry)
    â””â”€â”€ Point[] ExtractPoints(Geometry geometry)

ğŸ¯ <strong>SpatialReference : IEquatable&lt;SpatialReference&gt;</strong> <em>- SystÃ¨me de rÃ©fÃ©rence spatiale</em>
â”œâ”€â”€ <strong>Properties :</strong>
â”‚   â”œâ”€â”€ int WKID { get; }  <em># Well-Known ID</em>
â”‚   â”œâ”€â”€ string WKText { get; }  <em># Well-Known Text</em>
â”‚   â”œâ”€â”€ string Name { get; }
â”‚   â”œâ”€â”€ Unit Unit { get; }
â”‚   â”œâ”€â”€ GeographicTransformation Transformation { get; set; }
â”‚   â”œâ”€â”€ bool IsGeographic { get; }
â”‚   â””â”€â”€ bool IsProjected { get; }
â”œâ”€â”€ <strong>Methods :</strong>
â”‚   â”œâ”€â”€ Point Transform(Point point, SpatialReference target)
â”‚   â”œâ”€â”€ Envelope Transform(Envelope envelope, SpatialReference target)
â”‚   â”œâ”€â”€ bool CanTransformTo(SpatialReference target)
â”‚   â””â”€â”€ GeographicTransformation GetTransformation(SpatialReference target)
â”œâ”€â”€ <strong>Static Factory :</strong>
â”‚   â”œâ”€â”€ SpatialReference CreateFromWKID(int wkid)
â”‚   â”œâ”€â”€ SpatialReference CreateFromWKText(string wktext)
â”‚   â””â”€â”€ SpatialReference CreateFromEPSG(int epsgCode)
â””â”€â”€ <strong>Common Systems :</strong>
    â”œâ”€â”€ static SpatialReference WGS84 { get; }
    â”œâ”€â”€ static SpatialReference WebMercator { get; }
    â”œâ”€â”€ static SpatialReference NAD83 { get; }
    â””â”€â”€ static SpatialReference UTMZone(int zone, bool northern)</div>
                </div>

                <div class="card">
                    <h2>Enums et Types de Support</h2>
                    
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>ğŸ“ GeometryType Enum</h4>
                            <ul>
                                <li><strong>Point :</strong> GÃ©omÃ©trie ponctuelle</li>
                                <li><strong>Polyline :</strong> GÃ©omÃ©trie linÃ©aire</li>
                                <li><strong>Polygon :</strong> GÃ©omÃ©trie surfacique</li>
                                <li><strong>MultiPoint :</strong> Collection de points</li>
                                <li><strong>MultiLineString :</strong> Collection de lignes</li>
                                <li><strong>MultiPolygon :</strong> Collection de polygones</li>
                                <li><strong>MultiPatch :</strong> GÃ©omÃ©trie 3D complexe</li>
                                <li><strong>Unknown :</strong> Type indÃ©terminÃ©</li>
                            </ul>
                        </div>
                        <div class="feature-card">
                            <h4>ğŸ“ Unit Types</h4>
                            <ul>
                                <li><strong>LinearUnit :</strong> Meter, Foot, Kilometer, Mile</li>
                                <li><strong>AreaUnit :</strong> SquareMeter, Hectare, Acre, SquareFoot</li>
                                <li><strong>AngularUnit :</strong> Degree, Radian, Grad</li>
                                <li><strong>VolumeUnit :</strong> CubicMeter, Liter, CubicFoot</li>
                            </ul>
                        </div>
                        <div class="feature-card">
                            <h4>ğŸ” ValidationResult</h4>
                            <ul>
                                <li><strong>IsValid :</strong> bool - GÃ©omÃ©trie valide</li>
                                <li><strong>Errors :</strong> string[] - Liste des erreurs</li>
                                <li><strong>Warnings :</strong> string[] - Avertissements</li>
                                <li><strong>CanCorrect :</strong> bool - Correction possible</li>
                            </ul>
                        </div>
                        <div class="feature-card">
                            <h4>ğŸ¯ SpatialRelation Enum</h4>
                            <ul>
                                <li><strong>Intersects :</strong> GÃ©omÃ©tries se croisent</li>
                                <li><strong>Contains :</strong> Une contient l'autre</li>
                                <li><strong>Within :</strong> Une est dans l'autre</li>
                                <li><strong>Touches :</strong> GÃ©omÃ©tries se touchent</li>
                                <li><strong>Overlaps :</strong> Chevauchement partiel</li>
                                <li><strong>Crosses :</strong> Intersection sans inclusion</li>
                                <li><strong>Disjoint :</strong> Aucune intersection</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>Exemples d'Utilisation</h2>
                    
                    <div class="code-block">// CrÃ©ation et manipulation de gÃ©omÃ©tries
Point p1 = new Point(10.5, 20.3, 100.0);
Point p2 = new Point(15.7, 25.1, 110.5);

// Utilisation des opÃ©rateurs surchargÃ©s
Point midPoint = (p1 + p2) / 2.0;
double distance = p1 | p2;  // Produit scalaire

// CrÃ©ation d'une polyligne
Polyline line = new Polyline();
line.AddPoint(p1);
line.AddPoint(p2);
line.AddPoint(new Point(20.1, 30.5));

// Calculs avec GeometryEngine
double lineLength = GeometryEngine.Length(line, LinearUnit.Meter);
bool isValid = GeometryEngine.IsValid(line);

// CrÃ©ation d'un polygone avec trou
Polygon polygon = new Polygon();
polygon.SetExteriorRing(outerRing);
polygon.AddInteriorRing(innerRing);

// Validation topologique
ValidationResult validation = GeometryEngine.ValidateGeometry(polygon);
if (!validation.IsValid)
{
    foreach (string error in validation.Errors)
    {
        Console.WriteLine($"Erreur: {error}");
    }
}

// OpÃ©rations spatiales
if (GeometryEngine.Intersects(polygon, line))
{
    Geometry intersection = GeometryEngine.Intersection(polygon, line);
    Console.WriteLine($"Intersection trouvÃ©e: {intersection.Type}");
}

// Transformation de projection
SpatialReference utm = SpatialReference.UTMZone(18, true);
Point projectedPoint = utm.Transform(p1, SpatialReference.WGS84);</div>
                </div>

                <div class="card">
                    <h2>ğŸ”— Navigation</h2>
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4><a href="hierarchie-classes.html">â¬…ï¸ Retour HiÃ©rarchie Principale</a></h4>
                            <p>Vue d'ensemble de toutes les classes</p>
                        </div>
                        <div class="feature-card">
                            <h4><a href="hierarchie-data.html">â¡ï¸ Classes de DonnÃ©es</a></h4>
                            <p>Gestion des donnÃ©es spatiales</p>
                        </div>
                        <div class="feature-card">
                            <h4><a href="donnees-geospatiales.html">ğŸŒ DonnÃ©es GÃ©ospatiales</a></h4>
                            <p>FonctionnalitÃ©s mÃ©tier associÃ©es</p>
                        </div>
                        <div class="feature-card">
                            <h4><a href="catalogue-methodes.html">ğŸ“‹ Catalogue des MÃ©thodes</a></h4>
                            <p>RÃ©fÃ©rence complÃ¨te des mÃ©thodes</p>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>
</body>
</html>